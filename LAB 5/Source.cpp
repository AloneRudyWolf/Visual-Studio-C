// Классы и обьекты
#include "pch.h"
#include <iostream>


using namespace std;

//1. Синтаксис. Обьявление класса
// class Имя_Класса
// {
//    int hp; // Число ХП
//    double speed; // скорость персонажа
//    void heal(); // воччтановление ХП
//    void move(); // проигрывание анимации
// }
// Класс - фактическое описание пользовательского типа данных
// Обьект - экземпляр класса, конкретная реализауия в оперативное памяти
// Свойство(property) - переменная в составе класса
// Метод - функция в составе класса

// 2. Синтаксис обьявления обьекта и обращения к св-вам и методам
// Имя_Класса обьект1;
// обьект1.свойство1 = 1;
// обьект1.метод3()

class vehicle // игровое транспортное средство
{

public:
	double speed;
	char regnumber[6] = { 0 };
	unsigned char capacity;

	int vehicle1(int r/*могут быть входные параметры*/) //конструктор
	{

		cin >> r;
		cout << "Сработал конструктор vehicle " << endl;
		return(r);
	};
	~vehicle(/* НЕ могут быть входные параметры */) //деструктор
	{
		std::cout << "Сработал деструктор vehicle " << endl;
		return;
	};

	bool check_regnumber() // если зарегистрирован - true
	{
		// если метод небольшой - определение прямо в классе

		// если номер К370АО - возвращает true
		const char * true_number = "К370АО";
		bool result = true;
		for (int i = 0; i < 6; i++)
		{
			result = result && (true_number[i] == regnumber[i]);
		}
		//Запустить цикл проверки по всем шести элементам строки regnumber
		//если все элементы совпадают с true_number - return true;

		return result;
	}
	void add_passenger(int passengers);
	void accelerate(double delta_velocity);

};



int main()
{


	vehicle vehicle_object;
	vehicle_object.regnumber[0] = 'К';
	vehicle_object.regnumber[1] = '3';
	vehicle_object.regnumber[2] = '7';
	vehicle_object.regnumber[3] = '1';
	vehicle_object.regnumber[4] = 'А';
	vehicle_object.regnumber[5] = 'О';
	bool check_result;
	vehicle_object.check_regnumber();

	vehicle1();



	// 3. Спецификаторы доступа.
// К полям(свойства и методы) обьявленным в разделе public можно обращаться веде
// и из методов класса и снаружи, где виден обьект
// К полям(свойства и методы) обьявленным в разделе private и protected 
//можно обращаться только из методов самого класса. Различие обьясняется в следующей теме.

// 4. Конструктор и деструктор класса
// В случае, если при создании обьекта нужно выполнять сложные действия по инициализации, установлению
// сетевого соединения, действия с файлами, выделение памяти и тд эти действия прописываются
// в специальном методе - конструкторе
// Конструктор вызывается автоматически при создании обьекта.
// В случае, если при исчезновении обьекта нужно общесистемные ресурсы освобождать:
// закрывать порты, освобождать ОЗУ, сохранять файлы и тд - эти действия прописываются в методе
// деструкторе (вызывается автоматически при исчезании обьекта)

// не смотря на то что программист вручную не прописывает функцию конструктора и десктруквтора компилятор
// при анализе текста отслеживает когда обьект появляется и когда он исчезает
// и автоматически не я вно для программиста подставляет вызов конструктора и денструктора в коде.
// Конструктор не может возвращать параметры,но может иметь входные
// деструктор не может иметь ни входных,ни выходных параметров
// конструктором и деструктором автоматически назначается функция,имеющая то же имя,что и класс (деструктор с тильдой(~))
// определение методов снаружи класса
//обьявление класс остется обьявление(заголовок) метода
//
//тело метода переносится наружу вместе с копией заголовка
// к заголовку реализации добавляется "имя_класса::"
//




	getchar();
	return(0);

}